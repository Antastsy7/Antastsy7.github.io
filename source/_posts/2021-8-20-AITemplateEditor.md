---

title: AI编辑器
avatar: /assets/img/common/avatar.jpg
categories: Tools
comments: false
date: 2021-08-20 12:55:42
only:
- home
- category
- tag
photos: /assets/img/common/ai.jpg
---

这是我们项目之前用于编辑AI的工具，用wpf开发。编辑器版本较为古老缺少迭代，使用的体量却越来越大(AI节点就有几百个，AI树更是有几千多个)，因此对编辑器进行了较大幅的迭代优化。
#### 结构优化
左侧行为树列表因为treeview的问题，光是展开所有人的树就要等半天（但是又不能不加载），后续搜索关键字基本是一字一卡。

由于我们的树采用的是 protobuf ，是无法直接对里面的属性进行set的，加上proto只存了一些必要属性，为了方便统一管理和数据绑定，我在编辑器内加了一个抽象层。我把这个抽象层序列化为json，并在加载之后缓存下来，之后就不需要再次IO开销。同时我也给这个抽象层加了许多的属性，比如记录这棵树被其他树的引用情况，树的标签，注释，svn状态等等。类似的，我给AI节点列表也加了代理层，并且记录每个AI节点出现在哪个AI树中，方便新同学复用老节点时可以快速找到参考。
同时我还给编辑器加入了一些易用性强的模块，比如最近打开，置顶，查看树的层级结构，给树加上节点顺序标注等。

#### 调试优化
我们的策划之前调试AI是靠看log输出的，调试AI的难度不逊于调试代码，非常痛苦。由于调试时输出的log是本身是结构化的，我的思路是在游戏客户端加一个hook去捕获这些log，并将其发送给AI编辑器，由AI编辑器对其进行解析，最后可视化的展示在当前的行为树中。由于我们的命令行已经支持了“连续调试”“执行一步”这些接口（实际上是gm指令）只要我建立起了AI编辑器和游戏客户端的通信，就可以从AI编辑器主动发起并控制调试过程。AI编辑器可以把这些收到的log存到一个列表中，策划就可以手动拖动进度条查看AI的运行结果，方便策划追踪整个树的执行情况。

#### 模块参数
由于AI使用的越来越多，AI树的体量也越来越大，我们并不希望每当有新的怪物需求时就建一颗新的树，而是希望尽可能去复用老的树结构，所以我们有了将行为树参数化、模块化的想法。即写一个非常通用的行为树，通过参数来控制每个具体节点的行为，以复用一个结构满足不同场景的需求。我们搭配设计了模板树和模块参数，通过参数和树的组合来实现复用。我们在模块参数中定义了一系列变量，用这些变量去绑定原有行为树的某些参数，这样策划想复用的时候只需要在现有模块参数的基础上改变变量取值，而不用一个个参数去改了。
#### 项目复用
只要底层结构相同就可以复用（即最后生成的AI树都是用protobuf规定的）项目组可以定制自己需要的AI节点和一些配置文件。我们组的AI编辑器也顺利推广到了隔壁的S3项目组。