---
title: AI编辑器
author: slakijng
avatar: \assets\img\common\avatar.jpg
authorDesc: 
categories: 技术
comments: false
date: 2022-06-29 12:55:42
authorLink:
authorAbout:
tags:
keywords:
description:
photos:
---

这是我们项目之前就有的用于编辑AI的工具，用wpf开发。由于编辑器版本已经非常古老，使用的体量却越来越大(AI节点就有几百个，AI树更是有几千多个)，因此对编辑器进行了较大幅的迭代升级
## 结构优化
之前的都是有功能无脑往上加的，功能变多以后布局越发臃肿，这次统一了一下UI风格，全部采用 material design 的主题。
左侧参数列表因为结构问题，光是展开所有人的树就要等半天（但是又不能不加载）加上后续搜索基本是一字一卡，针对这块基本做了一次推倒重构。由于我们的树采用的是protobuf，直接读取里面的属性是无法对其进行set的，因此在编辑器内加了一个抽象层，用于做统一管理和绑定。
为了解决性能问题，我把这个抽象层序列化为json缓存，第一次生成之后不需要再次IO开销。同时后续我也给这个代理加了许多的属性，比如记录这棵树被其他树的引用情况，树的标签，注释，svn状态等等。类似的，我给AI节点列表也加了代理层，并且记录每个AI节点出现在哪个AI树中，方便新同学复用老节点时可以快速找到参考。
左侧加入标签页，管理作者的行为树和其他类别的行为树，加入一些易用性强的模块，比如最近打开，当前树结构等，给树加上节点顺序标注等。

## 调试优化
我们的策划之前调试AI是靠看log输出的，调试AI的难度不逊于调试代码。由于调试时输出的log是本身是结构化的，我的思路是在游戏客户端建一个hook，捕获这些输出的log，并将其发送给AI编辑器，然后由AI编辑器对其进行解析，最后可视化的展示在当前的行为树中。由于我们的命令行已经支持了“连续调试”“执行一步”这些接口，只要我建立起了AI编辑器和游戏客户端的通信，就可以从AI编辑器主动发起并控制调试过程。AI编辑器可以把这些收到的log存到一个列表中，策划就可以手动拖动进度条查看AI的运行结果，方便策划追踪整个树的执行情况。
## 模块参数
由于AI使用的越来越多，AI树的体量也越来越大，我们并不希望每当有新的怪物需求时就建一颗新的树，而是希望尽可能去复用老的树结构，所以我们有了将行为树参数化、模块化的想法，即写一个非常通用的行为树，通过参数来控制每个具体节点的行为，以复用一个结构满足不同场景的需求。我们搭配设计了模板树和模块参数，通过参数和树的组合来实现复用。
## 项目复用
只要底层结构都是相同，不同的项目组提供各自的AI节点和配置文件，就可以直接复用。AI编辑器也顺利推广到了隔壁的S3项目组。
## 踩坑经验
- 不要用protobuf，json保狗命
- 